---
title: "Leetcode 220"
date: 2019-09-09T00:19:34+08:00
---

### 220. 存在重复元素 II

> 给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。
>
> 示例 1:
>
> 输入: nums = [1,2,3,1], k = 3, t = 0
> 输出: true
> 示例 2:
>
> 输入: nums = [1,0,1,1], k = 1, t = 2
> 输出: true
> 示例 3:
>
> 输入: nums = [1,5,9,1,5,9], k = 2, t = 3
> 输出: false
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/contains-duplicate-iii
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



很惭愧,五月份做过这道题,九月份再看完全没有印象,看了官方题解才想起来思路,有必要记录下~毕竟事不过三.



### 问题的实质

> 使得 nums [i] 和 nums [j] 的差的绝对值最大为 t

数组中存在两个临近数字,间隔小于等于t. 

> 并且 i 和 j 之间的差的绝对值最大为 ķ

要维持原数组的下标  



上面两句就是这道题的实质,这道题分类是排序,那么先用各种排序思想的关键字套一下: 

- 快排: 基准点,划分,部分有序,位置
- 堆排序: top K 
- 桶排序: 映射,查找,原始数据无影响

**查找**,**原始数据无影响**  就是它了! 桶排序



### 要点解析

```java
/**
 * 基于桶排序 从当前桶或相邻的桶中寻找,并且只维护当前k个数字
 */
public class Q220 {
    private long getID(long i, long w) {
        //1. 
        return i < 0 ? (i + 1) / w - 1 : i / w;
    }

    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        if (t < 0) return false;
        Map<Long, Long> d = new HashMap<>();
        long w = (long) t + 1;
        for (int i = 0; i < nums.length; ++i) {
            long m = getID(nums[i], w);
            //2.  
            if (d.containsKey(m))
                return true;
            if (d.containsKey(m - 1) && Math.abs(nums[i] - d.get(m - 1)) < w)
                return true;
            if (d.containsKey(m + 1) && Math.abs(nums[i] - d.get(m + 1)) < w)
                return true;
            d.put(m, (long) nums[i]);
           //3. 
            if (i >= k) d.remove(getID(nums[i - k], w));
        }
        return false;
    }
}

```

#### 1. 划分桶 ==> 确定hash方式

 如果只考虑正数,我们需要以t为间隔划分桶 ==> [nt,(n+1)t]划分为一个桶,一个桶对应一个唯一的id,表示为:

```
id=num/(t+1)
```

如果是负数,我们需要以t为间隔划分桶 ==> [-n(t+1),-(n-1)(t+1)-1]划分为一个桶.

举个例子,假设t=4,那么[-5,-1] 对应 -1这个id.  基于语言的取整特性

```java
-4~-1 / 5 =0
```

而我们需要的是-1, 因此 针对负数 需要额外 -1 修正.

同时由于

```
-5 / 5 = -1
```

这样经过上面的修正就导致 -5/5 -1 =-2,而我们需要的是-1



为了满足上面两个条件,需要先对数字进行额外的 +1 处理,即

```
(-5+1)/5 -1 = -1
```

总结成公式就是:

```
id=(num-1)/(t+1)-1
```



#### 2. 从当前桶或相邻的桶中寻找

对于一个插入的数字num, 我们需要查看[num-t,num+t]这个范围内是否存在符合的数字,而num这个桶对应的范围只是上面这个范围的一部分,上一个桶/下一个桶中有一部分和这个范围重合,也需要查看.例如

t=4, num=3,那么我们需要查看的范围是[-1,7],对应[-5,-1],[0,4],[5-9]这三个桶.



#### 3. 只维护当前k个数字

> 并且 i 和 j 之间的差的绝对值最大为 ķ

这个约束指明: 即使在当前桶或相邻桶中找到了间隔小于等于t的数字,还不够,他们的下标的间隔还不能大于k, 显然我们的桶中无法记录下标信息(其实可以,但是那样代价太大,也不够优). 换个思路想,如果我们的桶中只记录nums[j-k,j]的数字,不就满足这个约束了. 因此维护一下桶,

```
if (i >= k) d.remove(getID(nums[i - k], w));
```

注意这里是在判断逻辑后才进行维护桶的操作,因此i==k时就需要删除,保证下一次循环的正确性.





### 总结

这道题利用桶排序的思想做起来很流畅,但是一些细节要费点头脑去想,希望此本对你有帮助. peace and love~